# P3 & P4 Implementation Ticket

## Overview

Continue the codebase improvements by implementing P3 (performance optimizations) and P4 (complex function refactoring) following the consensus recommendations from the code review.

## Prerequisites

- P0-P2 have been completed:
  - ✅ Logging implementation (no more DEBUG print statements)
  - ✅ Terminal pattern consolidation (`terminal_config.py`)
  - ✅ Configuration management (`app_config.py`)
  - ✅ Paste strategy pattern (`paste_strategies.py`)
  - ✅ Terminal detection caching (2-second TTL)

## P3: Additional Performance Optimizations

### 3.1 Optimize Subprocess Calls

**Problem**: Multiple subprocess.run() calls with capture_output create overhead.

**Solution**:

- Create a subprocess utility module with connection pooling
- Batch multiple detection calls where possible
- Consider using `python-xlib` for X11 (feature-gated, optional dependency)

**Implementation**:

```python
# Create subprocess_utils.py
class SubprocessManager:
    def __init__(self):
        self._command_cache = {}  # Cache frequently used command results

    def run_cached(self, cmd, cache_ttl=1.0):
        # Implementation here
```

### 3.2 Lazy Loading for Enhancement Module

**Problem**: Enhancement module loads even when Prompt Mode is disabled.

**Solution**:

- Move enhancement imports inside functions that use them
- Only initialize enhancement when first needed

**Files to modify**:

- `main.py` - Move enhance imports to lazy loading

## P4: Refactor Complex Functions

### 4.1 Priority Targets (Critical Complexity)

Based on the code analysis, these functions need immediate refactoring:

1. **enhance.py**:
   - `enhance_prompt()` - Complexity: 39, Length: 160 lines
   - `reconstruct_fragments()` - Complexity: 37, Length: 90 lines
   - `_should_merge_with_next()` - Complexity: 28, Length: 55 lines
   - `_is_valid_standalone()` - Complexity: 17

2. **model_config.py**:
   - `_initialize_default_models()` - Length: 160 lines
   - `call_with_fallback()` - Complexity: 14, Length: 71 lines

### 4.2 Refactoring Strategy

**Before starting**: Write characterization tests to lock current behavior!

```python
# tests/test_enhance_refactor.py
def test_enhance_prompt_preserves_behavior():
    # Capture current behavior with various inputs
    test_cases = [
        ("simple input", "expected output"),
        # Add edge cases
    ]
```

**Refactoring approach**:

1. Extract pure functions for each logical section
2. Create helper classes for complex state management
3. Use builder pattern for complex prompt construction

**Example refactor for enhance_prompt()**:

```python
# Before: 160-line monster function
def enhance_prompt(text, style, model):
    # ... 160 lines of mixed logic ...

# After: Clean separation
class EnhancementBuilder:
    def __init__(self, text, style):
        self.text = text
        self.style = style

    def build_system_prompt(self):
        # Extracted logic

    def build_user_prompt(self):
        # Extracted logic

    def apply_style_rules(self):
        # Extracted logic

def enhance_prompt(text, style, model):
    builder = EnhancementBuilder(text, style)
    system_prompt = builder.build_system_prompt()
    user_prompt = builder.build_user_prompt()
    return call_model(model, system_prompt, user_prompt)
```

## Additional Improvements to Consider

### 5.1 Error Recovery

**Current issue**: Many bare `except Exception:` blocks still exist.

**Solution**:

- Create custom exception hierarchy
- Add retry logic with exponential backoff for transient failures
- Log exceptions with full context

```python
# exceptions.py
class VoiceTranscribeError(Exception):
    """Base exception for voice-transcribe"""

class TerminalDetectionError(VoiceTranscribeError):
    """Failed to detect terminal window"""

class PasteError(VoiceTranscribeError):
    """Failed to paste content"""
```

### 5.2 Testing Infrastructure

**Current issue**: No automated tests for the improvements.

**Create**:

- `tests/test_terminal_detection.py` - Mock subprocess calls
- `tests/test_paste_strategies.py` - Test each strategy
- `tests/test_configuration.py` - Test env var overrides

### 5.3 Documentation

**Create or update**:

- `docs/CONFIGURATION.md` - Document all env vars and config options
- `docs/ARCHITECTURE.md` - Explain the new modular structure
- Update `README.md` with new configuration examples

## Testing Checklist

### Unit Tests

- [ ] Terminal detection with mocked subprocess
- [ ] Paste strategies with different contexts
- [ ] Configuration override from environment
- [ ] Cache TTL expiration

### Integration Tests

- [ ] Full paste flow on X11
- [ ] Full paste flow on Wayland
- [ ] Terminal vs non-terminal detection
- [ ] VS Code integrated terminal detection

### Performance Tests

- [ ] Measure subprocess call reduction
- [ ] Verify cache hit rates
- [ ] Profile memory usage with lazy loading

## Acceptance Criteria

1. **Performance**:
   - Terminal detection cache hit rate > 80% in typical usage
   - Subprocess calls reduced by at least 50%
   - No performance regression in transcription

2. **Code Quality**:
   - No function with cyclomatic complexity > 10
   - No function longer than 50 lines
   - Test coverage > 80% for new code

3. **Backwards Compatibility**:
   - All existing functionality preserved
   - Configuration defaults match previous behavior
   - No breaking changes to user experience

## Implementation Order

1. **Week 1**: P3 Performance
   - Day 1-2: Subprocess optimizations
   - Day 3: Lazy loading implementation
   - Day 4-5: Performance testing and tuning

2. **Week 2**: P4 Refactoring
   - Day 1: Write characterization tests
   - Day 2-3: Refactor enhance.py functions
   - Day 4: Refactor model_config.py
   - Day 5: Integration testing

3. **Week 3**: Polish
   - Day 1-2: Error handling improvements
   - Day 3-4: Documentation
   - Day 5: Final testing and review

## Resources

- Code review findings: See git history for consensus recommendations
- Complexity metrics: Run `radon cc -s *.py` to measure
- Test framework: Use pytest with fixtures for mocking

## Notes for Implementation

- Always run `LOG_LEVEL=DEBUG ./voice-transcribe` to see detailed logs
- Test with both `XDG_SESSION_TYPE=x11` and `XDG_SESSION_TYPE=wayland`
- Use `python -m pytest tests/` to run test suite
- Keep backwards compatibility - check `git diff` before committing

## Success Metrics

- Paste success rate: > 95% across all environments
- Performance: < 10ms for cached terminal detection
- Code quality: All functions pass radon complexity checks
- User experience: No noticeable latency or regressions

---

**Estimated effort**: 2-3 weeks for experienced Python developer
**Priority**: P3 (Performance) before P4 (Refactoring)
**Risk**: Low-Medium (tests mitigate refactoring risks)
